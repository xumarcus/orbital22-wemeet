= WeMeet 0.3.0 Developer Guide
Marcus Xu;
:toc:

Scheduling is a NP-hard problem. Essentially, our project provides a simple interface to CRUD a meeting (FE) / roster plan (BE) with some scheduling constraints, push it into the AI solver's task queue, and display them to the user to refine.

== Workflow
Throughout the project we aim to automate our development process as much as possible to reduce mistakes. at the cost of a higher learning curve than more beginner-friendly tech stacks such as MEAN. For instance, for a typical CRUD operation,

* Most validation constraints are specified and automatically handled
* ACL checks are specified with `@PreAuthorize` and `@PostAuthorize`. Behind the scenes, Spring Security checks users permission with high performance cache. This is to be refined in later versions.
* The relevant CRUD API is automatically generated by Spring Data REST. Edge cases are handled with custom controllers and DTOs integrated with Spring HATEOAS.
HATEOAS stands for Hypermedia as the Engine of Application State. This provides a uniform and RESTful API by ensuring discoverability.
* We write extensive integration tests for the API.
* Then the documentation is generated from tests.


== Architecture
Standard monolith model.

. Client calls API
. Controller intercepts and validates request
. Forward request to service layer
. Service sends queries to repositories
. Controller formats response

== Design choices
See xref:_tech_stack[] for a more exhaustive list of libraries we have picked.

=== Programming language
We choose Java, as our AI solver is JVM based. This means we stick to Javaâ€™s most common Spring Boot web framework.

=== UI framework
We choose Material UI because it has excellent React integration, it has many components, and it is free. We choose Syncfusion (even though it has poor React integration) because it has commercial-grade Data Grid and Scheduler components that are free under community license.

=== Database
We choose PostgresSQL because it comes with Heroku. That being said, another major factor is that relational databases are easier to iterate since data duplication is avoided. Especially at our scale NoSQL databases are just premature optimization. See http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/[why you should never use MongoDB] for more justification.

=== ORM
Spring Boot comes with Hibernate. Hibernate ORM enables developers to more easily write applications whose data outlives the application process.

== UI
.Pages
* Dashboard: Display the meetings that the current user manages and that invite current user.
* Home: Main page
* MeetingEdit: Edit the meeting that the current user manages. Use `Generate Roster` button to generate solution.
* MeetingRank: Provide rank preferences to time slots in meeting that invites current user
* MeetingViewSolution: View the solution generated from rank preferences. Publishing overwrites meeting allocations with those from the solution.

.File structure
* `components`
* `core`: Utilities and React Context
* `pages`: Routed by React Router. Assembled from components.
* `test`: Jest unit tests

== Database schema design
Standard relational 3NF normalized schema. Schema changes (migrations) are managed by Liquibase.

.Database schema
image::db.png[]

Note that `password` in the `users` table are `bcrypt` hashes. Associations are shown in the diagram and in code.

.Entities
* `User` (`users` table)
* `RosterPlan` (`roster_plan` table)
** `owner` the `User` who creates it
** `title`
** `solved`
*** `null` if not generated from solver
*** `false` if still in solver queue
*** `true` if processed by solver
** `parent` from which this `RosterPlan` is generated
** `minAllocationCount` the minimum number of time slots a user has to be allocated to
** `maxAllocationCount` the maximum number of time slots a user has to be allocated to
* `TimeSlot` (`time_slot` table)
** `startDateTime`
** `endDateTime`
** `capacity`
* `RosterPlanUserInfo` (`roster_plan_user_info` table): association between `User` and `RosterPlan`
** `locked` if the user has locked in their preferences
* `TimeSlotUserInfo` (`time_slot_user_info` table): association between `User` and `TimeSlot`
** `rank` the rank a user assigns to a time slot
** `available` if the user is available for the time slot

[#_tech_stack]
== Tech stack
Check `package.json` for frontend libraries and `pom.xml` for backend libraries.

=== Frontend

==== React
We chose React since it helps with component reuse.And we both only know React for UI.

==== React Router
For routing.

==== Material UI
Provides most of the UI components.

==== Syncfusion
Provides scheduler and data grid component. Requires community license.

=== Backend

==== PostgresSQL
See above.

==== Spring Boot
An opinionated framework that configures Spring, the web application framework.

==== Spring Security
Handles authentication and access control checks.

==== OptaPlanner
AI Constraint solver. Generates solutions for meeting schedules given ranks.

==== Liquibase
Handles database migrations. Synchronize DB schemas among developers.

==== H2 Database
In memory database for integration tests.

==== Spring Data Rest
Generates RESTful API from repositories. Ensure API discoverability, uniformity and RESTfulness.

==== Spring Rest Docs
Generates the requests and responses from integration tests for API reference.

==== Miscellaneous
* Lombok: Generates boilerplate code like getters and setters.
* MapStruct: Generates mappers between POJOs.
* Vavr: Functional programming

== Client implementation
This is a high level view of how we implement our UI. This means we won't include details like

> Upon submission, the details entered by the user are sent to the backend server using an axios POST request.

=== Context store
We use React context to persist user information in browser cache, to avoid repeated calls to server.

=== Navigation
Handled by React Router. A navigation bar is provided for convenience. The avatar (changing which is to be implemented) opens a menu for profile related actions such as logging out.

=== Account management
The user clicks on "Get Started" and that opens a modal containing forms to log in or register. Then when user submits using buttons, `POST` requests are sent to different routes.

==== Registration
Server response is persisted in context store.

==== Login
Server response is persisted in context store.

==== Logout
Clears context store.

==== Forgot password
To be implemented.

=== Syncfusion integration
For Syncfusion components to work with our existing API, some glue code has to be written (which is the hard part). Once written,

First define the data source
```javascript
return new DataManager({
    adaptor: new RestAdaptor({
      GET: RestAdaptor.get(url, resp => resp._embedded.rosterPlan),
      POST: RestAdaptor.post(API.ROSTER_PLAN),
      PUT: RestAdaptor.put(API.ROSTER_PLAN),
      DELETE: RestAdaptor.delete(API.ROSTER_PLAN, ({ key }) => key)
    })
})
```

Then provide data source and fields
```javascript
<GridComponent
  dataSource={dataSource}
  editSettings={editSettings}
  toolbar={TOOLBAR}
>
  <ColumnsDirective>
    <ColumnDirective
      field='id' headerText='ID' template={linkIDTemplate}
      width='120' textAlign='Center' isPrimaryKey
      isIdentity
    />
    <ColumnDirective field='title' headerText='Title' textAlign='Center' />
  </ColumnsDirective>
  <Inject services={[Edit, Toolbar]} />
</GridComponent>
```

Done. CRUD operations are now fully integrated. You can use the UI to CRUD and results will be persisted in database. See `RestAdaptor.js` for glue code, which we will gladly share. This is still a work in progress, as paging, filtering and sorting are yet to be integrated.

=== Dashboard
Displays meetings managed by user and those that invite current user. Both tabs are handled by Syncfusion data grids and fully integrate with our API for CRUD actions.

Each item contains a hyperlink on the ID field which brings user to respective meeting management pages. This is implemented using Syncfusion's custom template feature.

=== Scheduling
There are three views: `Edit`, `Rank`, and `ViewSolution`. Each uses Syncfusion Scheduler component, but calls different API and have different access control checks (to be implemented).

* In `Edit` mode the user can CRUD time slots, invited users, meeting title and other configurations.
* In `Rank` mode the user can provide ranking preferences.
* In `ViewSolution` mode the user can view results and publish them. More details are provided below.

Under the hood, the scheduler fully integrates with our API (as described above). Custom editor UI for time slots are also provided and integrated (as described above).

== Server implementation

=== Security
Handled by Spring Security. Session is persisted through cookies. CSRF protection is enabled, so the token is refreshed per request. Validation is for now only done server side.

In addition, we have set up a firewall to deny unauthenticated users most API calls. Access control checks will likely be in next release.

==== Registration
Once server receives `POST` request to `/api/users` route, we validate and persist user details into the database. Password is `bcrypt` hashed.

==== Login
Handled by Spring Security.

==== Logout
Handled by Spring Security.

==== Forgot password
To be implemented.

=== Scheduling
Handled by OptaPlanner.

==== Process
Essentially a persistent queue design.

. Once server receives `POST` request to `/api/rosterPlan` route with a valid `parent`, it will deep clone `parent` and persist the copy.
. The copy will be labeled unsolved.
. Then it will push the copy into a task queue.
. Eventually a solution will be found in another thread.
. Once it is solved, the AI allocations are persisted in the copy which will be labeled solved.
. User can view the result in `ViewSolution` mode.
. User can publish the result which overwrites the source with allocations from the result.

.Advantages
* Correctness. If any user modify their preferences or meeting configurations, the server will not overwrite these changes after the solver task is completed.
* Durability. If the task is still being solved, when the server fails, it will still be marked unsolved and can be handled later without data loss.
* Scalability. It may take a long time for the solver to solve meeting schedules with many users and rank preferences.

.Disadvantages
* Persistence is expensive.

==== Constraint programming
We need to specify constraints such that the AI knows how to optimize allocations. In OptaPlanner, constraints are given hard and soft penalties. The solver optimizes towards a solution that has minimum soft penalties and no hard penalties. However, we have only implemented four constraints and have yet to adjust their weights, and handle the case where solver cannot find a solution with no hard penalties.

The solver looks into all the (`User`, `TimeSlot`) pairs where the user is available for that time slot. Then it will consider

.List of constraints implemented
* `assignmentUserLockedConstraint`: If the user locked in the time slot, removing the user from the time slot will be hard-penalized.
* `assignmentRankConstraint`: If the user rank `n` for that time slot, assigning the user to the time slot will be soft-penalized by `n`.
* `userSizeConstraint`: If the user cannot be assigned a number of time slots within the limits specified in the configuration, the schedule will be hard-penalized.
* `timeSlotCapacityConstraint`: If assignments to the time slot exceeds its capacity, the schedule will be hard-penalized.

In the future, we plan to refine these weights and constraints to make it more fair.

== Documentation
Documentation is written in `.adoc` format, a Markdown dialect. We choose this because it integrates well with Spring Rest Docs.

In this example, we specified an integration test and a path where the input and output should be documented.
```java
@SpringBootTest
@AutoConfigureMockMvc
@AutoConfigureTestDatabase
@AutoConfigureRestDocs
@Import(H2Util.class)
class UserCreateIntegrationTest {
  @Autowired ObjectMapper objectMapper;
  @Autowired MockMvc mockMvc;

  @AfterEach
  public void tearDown(@Autowired H2Util h2Util, @Autowired CacheManager cacheManager) {
    // ...
  }

  @Test
  public void givenRequestWithInvalidEmail_whenRegister_thenBadRequest() throws Exception {
    Map<String, Object> map = new HashMap<>();
    map.put("email", "not-email");
    map.put("rawPassword", "password");

    this.mockMvc
        .perform(
            post("/api/users")
                .content(objectMapper.writeValueAsString(map))
                .contentType(MediaType.APPLICATION_JSON))
        .andExpect(status().isBadRequest())
        .andDo(document("post-users-registered-email-error"));
  }

  // ...
}
```

This is included in xref:api-reference.adoc[API Reference] as follows
```
Counterexamples
// include::{snippets}/post-users-registered-password-error/http-request.adoc[]
// include::{snippets}/post-users-registered-password-error/http-response.adoc[]
```

which generates developer-friendly, human-readable output like

Counterexamples
include::{snippets}/post-users-registered-password-error/http-request.adoc[]
include::{snippets}/post-users-registered-password-error/http-response.adoc[]

Moreover, if the tests failed the output is not generated. This ensures that the API is always in a correctly described state.